version 1.1

task fastp {
    meta {
        description: "Runs the Fastp tool for FASTQ quality control and trimming"
        outputs: {
            read_one_fastq_gz: "The gzipped trimmed read one FASTQ file. Only generated if `read_two_fastq` is supplied and `output_fastq` is `true`. Has the name `~{prefix}.R1.fastq.gz`.",
            read_two_fastq_gz: "The gzipped trimmed read two FASTQ file. Only generated if `read_two_fastq` is supplied and `output_fastq` is `true`. Has the name `~{prefifx}.R2.fastq.gz.",
            single_end_reads_fastq_gz: "The trimmed Single-End FASTQ file. Only generated if `read_two_fastq` is not supplied and `output_fastq` is `true`. Has the name `~{prefix}.fafstq.gz`.",
            report: "The HTML report generated by Fastp",
            report_json: "The JSON report generated by Fastp",
        }
    }

    parameter_meta {
        read_one_fastq: "Input FASTQ with read one. Can be gzipped or uncompressed."
        read_two_fastq: "Optional input FASTQ with read two. Can be gzipped or uncompressed."
        prefix: "Prefix for the output files. The extensions `.fastp.html`, `.fastp.json`, and TODO will be added."
        output_fastq: "Output FASTQ files (true) or only generate a Fastq report (false)?"
        disable_quality_filtering: "TODO"
        disable_length_filtering: "TODO"
        disable_adapter_trimming: "Disable adapter trimming"
        deduplicate: "Enable deduplication to drop the duplicated reads/pairs"
        phred64: "Input uses phred64 encoding. It will be converted to phred33 encoding in the output files."
        use_all_cores: "TODO"
        n_base_limit: "TODO"
        qualified_quality: "TODO"
        unqualified_percent: "TODO"
        average_quality: "TODO"
        length_required: "TODO"
        length_limit: "TODO"
        trim_front_r1: "Number of bases to trim from the front of read one"
        trim_tail_r1: "Number of bases to trim from the tail of read one"
        trim_front_r2: "Number of bases to trim from the front of read two"
        trim_tail_r2: "Number of bases to trim from the tail of read two"
        max_length_r1: "Maximum length of read one. Reads longer than this will be trimmed from the tail."
        max_length_r2: "Maximum length of read two. Reads longer than this will be trimmed from the tail."
        modify_disk_size_gb: "Add to or subtract from dynamic disk space allocation. Default disk size is determined by the size of the inputs. Specified in GB."
        ncpu: "Number of cores to allocate for task"
    }

    input {
        File read_one_fastq
        File? read_two_fastq
        String prefix = sub(
            basename(read_one_fastq),
            "(([_.][rR](?:ead)?[12])((?:[_.-][^_.-]*?)*?))?\\.(fastq|fq)(\\.gz)?$",
            ""  # Once replacing with capturing groups is supported, replace with group 3
        )
        Boolean output_fastq = true
        Boolean disable_quality_filtering = false
        Boolean disable_length_filtering = false
        Boolean disable_adapter_trimming = false
        Boolean deduplicate = false
        Boolean phred64 = false
        Boolean use_all_cores = false
        Int n_base_limit = 5
        Int qualified_quality = 15
        Int unqualified_percent = 40
        Int average_quality = 0
        Int length_required = 15
        Int length_limit = 0
        Int trim_front_r1 = 0
        Int trim_tail_r1 = 0
        Int trim_front_r2 = 0
        Int trim_tail_r2 = 0
        Int max_length_r1 = 0
        Int max_length_r2 = 0
        Int modify_disk_size_gb = 0
        Int ncpu = 3
    }

    Float input_size = size(read_one_fastq, "GiB")
        + (if defined(read_two_fastq) then size(read_two_fastq, "GiB") else 0)
    Int disk_size_gb = ceil(input_size) + 10 + modify_disk_size_gb

    command <<< 
        set -euo pipefail

        n_cores=~{ncpu}
        if ~{use_all_cores}; then
            n_cores=$(nproc)
        fi

        # set ENV variables for `fastp`
        export LC_ALL=C.UTF-8
        export LANG=C.UTF-8

        fastp \
            -i "~{read_one_fastq}" \
            ~{"-I '" + read_two_fastq + "'"} \
            ~{(
                if output_fastq
                then "-o '" + (
                    if defined(read_two_fastq)
                    then "~{prefix}.R1.fastq.gz"
                    else "~{prefix}.fastq.gz"
                ) + "'"
                else ""
            )} \
            ~{(
                if (defined(read_two_fastq) && output_fastq)
                then "-O '" + prefix + ".R2.fastq.gz'"
                else ""
            )} \
            ~{if phred64 then "--phred64" else ""} \
            ~{if disable_quality_filtering then "--disable_quality_filtering" else ""} \
            -n ~{n_base_limit} \
            -q ~{qualified_quality} \
            -u ~{unqualified_percent} \
            -e ~{average_quality} \
            ~{if disable_length_filtering then "--disable_length_filtering" else ""} \
            -l ~{length_required} \
            --length_limit ~{length_limit} \
            ~{if disable_adapter_trimming then "--disable_adapter_trimming" else ""} \
            --trim_front1 ~{trim_front_r1} \
            --trim_tail1 ~{trim_tail_r1} \
            --trim_front2 ~{trim_front_r2} \
            --trim_tail2 ~{trim_tail_r2} \
            --max_len1 ~{max_length_r1} \
            --max_len2 ~{max_length_r2} \
            -R "~{prefix} report" \
            --thread "$n_cores" \
            ~{if deduplicate then "--dedup" else ""} \
            -h "~{prefix}.fastp.html" \
            -j "~{prefix}.fastp.json"
    >>>

    output {
        File? read_one_fastq_gz = prefix + ".R1.fastq.gz"
        File? read_two_fastq_gz = prefix + ".R2.fastq.gz"
        File? single_end_reads_fastq_gz = prefix + "fastq.gz"
        File report = prefix + ".fastp.html"
        File report_json = prefix + ".fastp.json"
    }

    runtime {
        cpu: ncpu
        disks: "~{disk_size_gb} GB"
        container: "quay.io/biocontainers/fastp:1.0.1--heae3180_0"
        maxRetries: 1
    }
}
